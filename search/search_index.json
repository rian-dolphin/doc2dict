{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to doc2dict","text":"<p>doc2dict is a package to quickly parse documents in <code>pdf</code>, <code>html</code>, <code>xml</code>, and <code>txt</code> formats. It supports the datamule project.</p> Package is in early development"},{"location":"whitepaper/","title":"High Speed Document Algorithmic Parsing","text":""},{"location":"whitepaper/#abstract","title":"Abstract","text":"<p>Parsing documents that are human readable into machine readable form is difficult due to under the hood variation. Here is my attempt at providing a fast, robust generalized approach, that can be easily modified to account for variation in documents.</p> Download as PDF Caveats <p>This is not meant to be a perfect parsing approach. It's meant to be a \"good enough\" approach that is fast enough to parse the entire SEC corpus on a personal laptop. This is also in an early stage - things will change.</p> Terminology <p>I don't know the right words to use. If you do, please email me and/or bully me into correcting the terminology.</p>"},{"location":"whitepaper/#general","title":"General","text":""},{"location":"whitepaper/#approach","title":"Approach","text":"<ol> <li>Convert messy document into a simple list of instructions.</li> <li>Convert the list of instructions into dictionary using a set of rules that can be easily tailored for the document.</li> </ol> <p>The idea here is to turn a complex problem that is hard to solve, into a simple problem, that is easy to solve. * Nested html is hard to understand -&gt; the same html in list form is easy * Raw pdfs are hard to understand -&gt; the same pdf in list form is easy</p> <p>We can then convert from the (flat) list form into a nested dictionary by using simple rules like \"bigger headers have higher nesting\" as well as specify where certain headers go - \"item 1a risk factors should be nested under part i\".</p> <p>This also makes the parsing easier to modify for less technical users. A grad student in economics is unlikely to be able to modify the walk through a html document to properly account for style inheritance, but likely can modify rules such as \"ignore italics for header selection\".</p>"},{"location":"whitepaper/#examples","title":"Examples","text":"<p>Instructions List: <pre><code>[{'text': 'PART I', 'text-style': 'all_caps', 'left-indent': 8.0, 'font-size': 13.33, 'text-center': True, 'bold': True}]\n[{'text': 'ITEM 1. BUSINESS', 'text-style': 'all_caps', 'left-indent': 8.0, 'font-size': 15.995999999999999, 'text-center': True, 'bold': True}]\n[{'text': 'GENERAL', 'text-style': 'all_caps', 'left-indent': 8.0, 'font-size': 13.33, 'text-center': True, 'underline': True}]\n[{'text': 'Embracing Our Future', 'left-indent': 8.0, 'font-size': 13.33, 'bold': True}]...\n</code></pre></p> <p>Dictionary <pre><code>        \"37\": {\n            \"title\": \"PART I\",\n            \"standardized_title\": \"parti\",\n            \"class\": \"part\",\n            \"contents\": {\n                \"38\": {\n                    \"title\": \"ITEM 1. BUSINESS\",\n                    \"standardized_title\": \"item1\",\n                    \"class\": \"item\",\n                    \"contents\": {\n                        \"39\": {\n                            \"title\": \"GENERAL\",\n                            \"standardized_title\": \"\",\n                            \"class\": \"predicted header\",\n                            \"contents\": {\n                                \"40\": {\n                                    \"title\": \"Embracing Our Future\",...\n</code></pre></p>"},{"location":"whitepaper/#mapping-dictionaries","title":"Mapping Dictionaries","text":"<p>I call the set of rules used to convert the list of instructions into a dictionary a \"mapping dict\". The idea is that a less technical user who will have trouble tweaking the engine can easily modify a list of rules that tweak the output.</p>"},{"location":"whitepaper/#example","title":"Example","text":"<pre><code>dict_10k_html = {\n    ('part',r'^part\\s*([ivx]+)$') : 0,\n    ('signatures',r'^signatures?\\.*$') : 0,\n    ('item',r'^item\\s*(\\d+)\\.?([a-z])?') : 1,\n}\n</code></pre> <p>The above mapping dict tells the parser to assign class 'part' to predicted headers and assign hierarchy '0' or root level. It then uses the capture group <code>([ivx]+)</code> and the class to determine the standarized_title.</p>"},{"location":"whitepaper/#html","title":"HTML","text":"<p>The basic html approach has already been implemented. Ballpark speed is about 500 pages per second on my two year old personal laptop.</p>"},{"location":"whitepaper/#approach_1","title":"Approach","text":"<ol> <li>Iterate through the html file, keeping track of attributes that apply for each text node, with special handling for tables to create the instructions list. Output each text node as an instruction on the same line if the two text nodes visually appear on the same line.</li> <li>For the instructions list, determine which instructions are likely to be headers. If an instruction is a header, determine hierarchy with the aid of a mapping dict if present.</li> </ol>"},{"location":"whitepaper/#tables","title":"Tables","text":"<ol> <li>Construct a matrix with each cell representing a cell in the table</li> <li>If a cell spans multiple rows or columns, duplicate the cell in the matrix</li> <li>Remove rows and columns that are considered empty - e.g. have only empty characters</li> <li>Remove rows and columns that contain no unique information - e.g. if a column is a subset of another column, remove it.</li> </ol> <p>TODO</p> <ul> <li>Currently removes unmatched parenthesis columns, in the future will merge them</li> <li>Currently does not handle indents - many tables can be split into multiple tables using information from indents</li> </ul> Goal <p>The goal here is not to perfectly parse tables. We can get close, but often the information for html tables is above the table in a seperate block. </p>"},{"location":"whitepaper/#visualization","title":"Visualization","text":"<p>Visualization is important for both the instructions_list stage and the final dict stage. Visualization lets users quickly debug whether the parser is working as expected, and what to tweak.</p>"},{"location":"parsing/html/","title":"HTML","text":""},{"location":"parsing/html/#quickstart","title":"Quickstart","text":"<pre><code># Load your html file\nwith open('apple_10k_2024.htm','r') as f:\n    content = f.read()\n\n# Convert to dictionary\ndct = html2dict(content,mapping_dict=None)\n</code></pre>"},{"location":"parsing/html/#example","title":"Example","text":"<pre><code>...\n\"37\": {\n    \"title\": \"PART I\",\n    \"standardized_title\": \"parti\",\n    \"class\": \"part\",\n    \"contents\": {\n        \"38\": {\n            \"title\": \"ITEM 1. BUSINESS\",\n            \"standardized_title\": \"item1\",\n            \"class\": \"item\",\n            \"contents\": {\n                \"39\": {\n                    \"title\": \"GENERAL\",\n                    \"standardized_title\": \"\",\n                    \"class\": \"predicted header\",\n                    \"contents\": {\n                        \"40\": {\n                            \"title\": \"Embracing Our Future\",\n...\n\"292\": {\n        \"table\": [\n            [\n                \"Name\",\n                \"Age\",\n                \"Position with the Company\"\n            ],\n            [\n                \"Satya Nadella\",\n                \"56\",\n                \"Chairman and Chief Executive Officer\"\n            ],\n...\n</code></pre>"},{"location":"parsing/html/#tweaking-the-engine-for-your-use-case","title":"Tweaking the engine for your use case","text":"I will make this section better soon <p>I just want to get the basic docs out!</p>"},{"location":"parsing/html/#debugging","title":"Debugging","text":"<pre><code>from doc2dict import convert_html_to_instructions, convert_instructions_to_dict, visualize_instructions, visualize_dict\n\n# load your html file\nwith open('tesla10k.htm','r') as f:\n    content = f.read()\n\n# convert html to a series of instructions\ninstructions = convert_html_to_instructions(content)\n\n# visualize the conversion\nvisualize_instructions(instructions)\n\n# convert instructions to dictionary\ndct = html2dict(content,mapping_dict=None)\n\n# visualize dictionary\nvisualize_dict(dct)\n</code></pre>"},{"location":"parsing/html/#writing-your-own-mapping-dictionaries","title":"Writing your own mapping dictionaries","text":"Experimental <p>If you write a mapping dict, and I change something so it stops working - please email me.</p> <p>Mapping dicts currently work by specifying the class of the section header: <code>part</code>, regex for section header <code>r'^part\\s*([ivx]+)$'</code> where the capture group <code>([ivx]+)</code> and class <code>part</code> determine the <code>standardized_title</code>, and the level, where <code>0</code> is the root.</p> <p>In this example, <code>items</code> will always be nested under <code>parts</code>. <pre><code>dict_10k_html = {\n    ('part',r'^part\\s*([ivx]+)$') : 0,\n    ('signatures',r'^signatures?\\.*$') : 0,\n    ('item',r'^item\\s*(\\d+)\\.?([a-z])?') : 1,\n}\n</code></pre></p>"},{"location":"parsing/pdf/","title":"PDF","text":"Very Early Stage <p>This code is in a very early stage.</p>"},{"location":"parsing/pdf/#quickstart","title":"Quickstart","text":"<pre><code># Load your pdf file\nwith open('apple_10k_2024.pdf','rb') as f:\n    content = f.read()\n\n# Convert to dictionary\ndct = pdf2dict(content,mapping_dict=None)\n</code></pre>"},{"location":"parsing/pdf/#benchmarks","title":"Benchmarks","text":"<ul> <li>About 200 pages per second single threaded.</li> </ul> multithreading <p>pdf2dict can't be run multithreaded due to the limitations of pypdfium2</p>"},{"location":"parsing/pdf/#compatibility","title":"Compatibility","text":"<p>Requires pdfs with underlying text structure so no scans yet. </p> <p><code>convert_scan_to_instructions</code> would be fairly straightforward to implement. Font-size can be inferred from bounding boxes, as can line alignment. Rotation probably won't be an issue for decent scans like the ones submitted to the SEC.</p> <p>The issue is performance.</p> <p>The point of <code>doc2dict</code> is mostly that it's fast. Local OCR such as pytesseract would put a hard cap of 10 pages per second.</p> <p>This is too slow to be useful for my use-case. Here's a benchmark.</p> <p>Convert all 2024 Annual Report to Shareholders to dict form 2000 a year * mean 50 pages / 200 pages per second = 500 seconds = ~ 10 minutes. (PDF Parser)</p> <p>Where as a scan parser would take at least 200 minutes ~ 3 hours.</p> <p>I think the solution will be to write a scan parser that takes input of bounding boxes/ minimum features required as input. Users can then use their preferred OCR - e.g. local, Google, AWS, etc for the slow part.</p>"},{"location":"parsing/pdf/#todo","title":"TODO","text":"<p>think about tables get center get other old attributes like indent</p>"},{"location":"parsing/pdf/#issues","title":"Issues","text":"<ul> <li>Adobe PDF encodings return weird characters.</li> </ul>"},{"location":"parsing/todo/","title":"TODO","text":"<ul> <li>Seperate instructions into own directory</li> <li>add rules  option to relax headers restrctions, e.g. useful for form 10-D https://www.sec.gov/Archives/edgar/data/1766367/000188852425005427/dma19b10_10d-202503.htm</li> <li>modify base pdf parsing mapping dict to user underline - then test with APP NTC form.</li> </ul>"}]}